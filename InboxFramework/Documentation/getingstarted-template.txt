Inbox.framework Documentation
-----------------------------

The Inbox iOS framework provides a native interface to the Inbox API, with additional features that make it easy to build full-fledged mail apps for iOS or add the email functionality you need to existing applications.

The Inbox Framework:

- Includes pre-built view controllers for common tasks such as composing email, viewing a list of threads, and authorizing an account.

- Provides native, Objective-C models for threads, messages, contacts, and attachments, and high-level methods for interacting with them.

- Automatically caches data in an SQLite store, allowing you to create applications with great offline behavior with very little effort.

- Allows you to load individual slices of data from the Inbox API, such as a list of threads in the user's inbox with attachments, or create robust email applications that maintain a local cache and sync the user's entire mailbox.

- Comes with kickass sample apps. <links>

Getting Started with Inbox.framework
------------------------------------

To use the Inbox framework in your application, you need to obtain an Inbox App ID from https://developers.inboxapp.com/ and download the latest version of the Inbox SDK from https://developers.inboxapp.com/ios.

1. Drag and drop Inbox.framework into your Xcode project and add an import to your application's .pch header file:

    #import <Inbox/Inbox.h>

2. Add your Inbox App ID to your application's Info.plist file as 'INAppID'.

3. Add code to your App Delegate to handle authorization callbacks:

    - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
    {
        return [[INAPIManager shared] handleURL: url];
    }

4. Find an appropriate place in your application to ask the user to sign into their email account. If you're building a full-fledged mail client, you should ask users to sign in to their email immediately. If your application needs email access for a particular feature, you should prompt users to log in to their email when they access that feature.

Call INAPIManager's authenticateWithEmail:andCompletionBlock: to begin the login process. This method directs the user to their email provider (Gmail, Exchange, etc.) in Safari to enter their account credentials. When authorization is completed and Inbox has received an auth token, the completion block runs and your application can dismiss login UI and begin displaying mail.

    NSString * email = @"ben@inboxapp.com";
    [[INAPIManager shared] authenticateWithEmail:email andCompletionBlock:^(BOOL success, NSError *error) {
        if (success)
            // the user approved us to access their account - let's go!
        else if (error)
            [UIAlertView alloc] init....
    }];

5. Do something with the user's inbox. Click one of the links below to choose your own adventure and explore what you can do with Inbox!
	- Display unread threads
	- Display attachments
	- Compose drafts and send mail


Display Unread Threads
======================

Inbox makes it easy to display threads, messages, contacts and other information from the user's mailbox. To fetch Inbox objects, you use an instance of an INModelProvider, which wraps underlying calls to the local cache, the Inbox API, and the Inbox realtime service to provide you with the view you want.

INModelProvider is somewhat similar to Core Data's NSManagedResultsController and YapDatabase's concept of "Views". The goal is to make it easy to build rich, realtime views of the user's mail and hide the complexity behind retrieving objects, which could come from a cache, be streamed via a socket connection, or fetched via the API.

To display data, your application needs to:
- Create and configure an INModelProvider
- Implement the INModelProviderDelegate protocol

Creating and Configuring an INModelProvider
=========

Here's an example that shows how to create and configure a model provider for displaying unread threads:

    // fetch a namespace, which represents a particular email address our auth token provides access to.
    INNamespace * namespace = [[[INAPIManager shared] namespaces] firstObject];

    // create a new thread provider for displaying threads in that namespace
    INThreadProvider * provider = [namespace newThreadProvider];

    // configure the provider to display only unread threads using an NSPredicate
    [provider setItemFilterPredicate: [NSComparisonPredicate predicateWithFormat: @"ANY tagIDs = %@", INTagIDUnread]];

    // configure the provider to sort items by their last message date
    [provider setItemSortDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@"lastMessageDate" ascending:NO]]];

    // start monitoring the provider for data
    [provider setDelegate: self];


Once you've created a provider, you can configure it by providing an NSPredicate. In the example above, we use a predicate to limit our view to threads matching "ANY tagIDs = 'unread'". The Inbox framework uses NSPredicate extensively. Under the hood, the predicates are translated into filter parameters for API calls, and into SQL WHERE clauses for retrieving cached data. The predicate is applied to objects as they change, so marking a thread as 'read' automatically triggers that thread to be removed from your provider's displayed set.

Note: NSCompoundPredicates are supported, but only AND predicates can be used at this time. Comparison predicates can filter based on a variety of properties, but not all of them. For example, you can't filter messages based on message body. See the documentation for INThread, INMessage, etc. to see which properties you can use in prediates. For advanced filtering, check out the Inbox search API.

Similarly, INModelProvider uses sort descriptors to order the models it provides. You can specify one or more sort descriptors to order data in your view.


Implementing the INModelProviderDelegate protocol
==========

INModelProvider defines several delegate methods that you should implement to display your view's data. Though you can access the provider's result set directly using the -items method, the items being displayed may change at any time and there may not be items to display immediately after the provider is created. Your view should implement the delegate protocol and update to reflect changes as they happen.

Here's an example of a typical provider delegate implementation:

/* Called when the items array of the provider has changed substantially. You should
 refresh your interface completely to reflect the new items array. */

- (void)providerDataChanged:(INModelProvider*)provider
{
	[_tableView reloadData];
}

/* Called when objects have been added, removed, or modified in the items array, usually
 as a result of new data being fetched from the Inbox API or published on a real-time
 connection. You may choose to refresh your interface completely or apply the individual
 changes provided in the changeSet. */

- (void)provider:(INModelProvider*)provider dataAltered:(INModelProviderChangeSet *)changeSet
{
	[_tableView beginUpdates];
	[_tableView deleteRowsAtIndexPaths:[changeSet indexPathsFor: INModelProviderChangeRemove] withRowAnimation:UITableViewRowAnimationLeft];
	[_tableView insertRowsAtIndexPaths:[changeSet indexPathsFor: INModelProviderChangeAdd] withRowAnimation:UITableViewRowAnimationTop];
	[_tableView endUpdates];
	[_tableView reloadRowsAtIndexPaths:[changeSet indexPathsFor: INModelProviderChangeUpdate] withRowAnimation:UITableViewRowAnimationNone];
}

/* Called when an attempt to load data from the Inbox API has failed. If you requested
 the fetch by calling -refresh on the model provider or modifying the sort descriptors
 or filter predicate, you may want to display the error provided. */

- (void)provider:(INModelProvider*)provider dataFetchFailed:(NSError *)error
{
	[[[UIAlertView alloc] initWithTitle:@"Error!" message:[error localizedDescription] delegate:nil cancelButtonTitle:@"OK" otherButtonTitles: nil] show];
}

/** Called when the provider has fully refresh in response to an explicit refresh request
 or a change in the item filter predicate or sort descriptors. */
- (void)providerDataFetchCompleted:(INModelProvider*)provider
{
	// hide refresh UI
}


